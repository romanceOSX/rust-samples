--> file:///Users/romance/.rustup/toolchains/stable-aarch64-apple-darwin/share/doc/rust/html/book/ch19-00-patterns.html

pattern
    It consist of a combination of the following
        - literals
        - destructed arrays, enums, structs, or tuples
        - variables
        - wildcards
        - placeholders

    a pattern describes the shape of data

    to use a pattern we have to compare it to some value
    If the value matches the pattern, we are now able to use the value parts in the code

    refutable vs irrefutable

Where do they appear?
    - matches
        - they have to be exaustive
    - if let
        - a shorter way to write a match that only matches one case

    match vs if let
        In match we can only compare to one value, in the other hand, an iflet can
        compare to anything, even unrelated stuff

    - while let

    - for loops
        the value directly after the 'for' is a pattern
        'for x in y', x is the pattern

    - let statements
        let PATTERN = EXPRESSION;
        
    - function parameters   
        
    in some places the patterns need to be refutable, in other irrefutable

Refutability
    - irrefutable
        patterns that will match no matter the value
        The follwoing expressions only accept irrefutable patterns:
            - let statements
            - for loops
        Why is that? because rust can't do anything useful if those patterns don't match

    - refutable
        patterns that can fail

    match arms should use refutable patterns except for the last one, which can match
    anything making the match exhaustive

let-else vs iflet, match
    The scope of the bindings within an let-else is within the enclosing scope,
    in contrast to the match or if-let

    The use case for an iflet is if for example we want to bring a variable out of
    a value to the current scope and only care for that specific case

Using patterns
    match
        - we use '|' to match multiple values in the same branch
        - we can also use a range if the value type allows us to do so by doing "start ..= end"
